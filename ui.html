<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ApexCharts → SVG 2</title>
  <link href="https://fonts.googleapis.com/css2?family=Anek+Latin:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    body { 
      font-family: 'Anek Latin', Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans"; 
      margin: 0; 
      height: 100vh;
      min-height: 800px;
      min-width: 1200px;
      display: flex;
      flex-direction: column;
    }
    
    
    .main-content {
      display: flex;
      flex: 1;
      height: 100vh;
      overflow: hidden;
    }
    
    .config-section {
      width: 420px;
      background: #F8F9FA;
      border-right: 1px solid #E5E7EB;
      display: flex;
      flex-direction: column;
      height: 100vh;
      transition: width 0.3s ease;
    }
    
    .config-section.collapsed {
      width: 420px;
    }
    
    .config-content {
      padding: 16px;
      flex: 1;
      overflow-y: auto;
    }
    
    .config-buttons {
      padding: 16px;
      border-top: 1px solid #E5E7EB;
      background: #F8F9FA;
      flex-shrink: 0;
    }
    
    .preview-section {
      flex: 1;
      background: #F8F9FA;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      overflow: auto;
      height: 100vh;
    }
    
    .preview-section.hidden {
      display: none;
    }
    
    .section-title {
      font-size: 20px;
      font-weight: 600;
      color: #374151;
      margin-bottom: 16px;
      text-align: left;
    }
    
    .row { 
      display: flex; 
      gap: 8px; 
      align-items: center; 
      margin: 12px 0; 
    }
    
    label { 
      width: 100px; 
      font-size: 12px; 
      color: #374151; 
      font-weight: 500;
    }
    
    input, select, textarea { 
      flex: 1; 
      font-size: 12px; 
      padding: 8px 10px; 
      border: 1px solid #D1D5DB;
      border-radius: 4px;
      background: white;
    }
    
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: #3B82F6;
      box-shadow: 0 0 0 1px #3B82F6;
    }
    
    #preview { 
      border: 1px solid #E5E7EB; 
      border-radius: 8px; 
      padding: 16px; 
      background: white;
      margin: auto;
    }
    
    .button-group {
      display: flex;
      gap: 8px;
      width: 100%;
    }
    
    button { 
      padding: 10px 16px; 
      font-size: 12px; 
      border: 1px solid #D1D5DB;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      font-weight: 500;
      flex: 1;
    }
    
    button:hover {
      background: #F9FAFB;
    }
    
    button#insert {
      background: #3B82F6;
      color: white;
      border-color: #3B82F6;
    }
    
    button#insert:hover {
      background: #2563EB;
    }
    
    .toggle-button {
      position: absolute;
      top: -4px;
      right: 0px;
      width: 32px;
      height: 32px;
      border: 1px solid #D1D5DB;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      color: #6B7280;
      transition: all 0.2s ease;
      z-index: 10;
    }
    
    .toggle-button:hover {
      background: #F9FAFB;
      border-color: #9CA3AF;
      color: #374151;
    }
    
    .config-header {
      position: relative;
    }

    /* Tab styles */
    .tab-container {
      margin-top: 8px;
      width: 100%;
    }

    .tab-nav {
      display: flex;
      padding: 4px;
      gap: 4px;
      background-color: #edf2f7;
      /* border-bottom: 1px solid #E5E7EB; */
      margin-bottom: 12px;
      border-radius: 8px;
    }

    .tab-button {
      padding: 8px 16px;
      font-size: 12px;
      /* border-radius: 0px; */
      border: none;
      background: transparent;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      color: #6B7280;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .tab-button:hover {
      color: #374151;
      background: #F9FAFB;
    }

    .tab-button.active {
      color: #3B82F6;
      /* border-bottom-color: #3B82F6; */
      box-shadow: 0 2px 2px 0 rgba(148, 163, 184, 0.5);
      font-weight: 600;
      background-color: #ffffff;
      /* box-shadow: 0 2px 0 0 #3B82F6; */
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .tab-content textarea {
      width: 100%;
      box-sizing: border-box;
    }

    /* Table styles */
    .table-container {
      max-height: 300px;
      overflow: auto;
      border: 1px solid #E5E7EB;
      border-radius: 4px;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      table-layout: fixed;
      min-width: 500px; /* Ensure minimum width for horizontal scrolling */
    }

    .data-table th,
    .data-table td {
      padding: 6px 8px;
      text-align: left;
      border-bottom: 1px solid #F3F4F6;
      vertical-align: middle;
    }

    .data-table th:first-child,
    .data-table td:first-child {
      width: 100px;
      min-width: 100px;
    }

    .data-table th:not(:first-child),
    .data-table td:not(:first-child) {
      width: 150px;
      min-width: 150px;
    }

    .data-table th {
      background: #F9FAFB;
      font-weight: 600;
      color: #374151;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    .data-table input {
      width: 100%;
      border: none;
      background: transparent;
      padding: 2px 4px;
      font-size: 12px;
      font-family: inherit;
    }

    .data-table input:focus {
      outline: none;
      background: white;
      border: 1px solid #3B82F6;
      border-radius: 2px;
    }

    .table-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    .table-controls button {
      padding: 6px 12px;
      font-size: 11px;
      border: 1px solid #D1D5DB;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      font-weight: 500;
    }

    .table-controls button:hover {
      background: #F9FAFB;
    }

    .add-series-btn {
      background: #10B981 !important;
      color: white !important;
      border-color: #10B981 !important;
    }

    .add-series-btn:hover {
      background: #059669 !important;
    }

    .remove-series-btn {
      background: #EF4444 !important;
      color: white !important;
      border-color: #EF4444 !important;
    }

    .remove-series-btn:hover {
      background: #DC2626 !important;
    }

    /* X button styles for column and row removal */
    .remove-column-btn, .remove-row-btn {
      width: 16px;
      height: 16px;
      min-width: 16px;
      max-width: 16px;
      border: 0px solid #ffffff;
      border-radius: 50%;
      padding: 0;
      background: transparent;
      color: #6B7280;
      font-size: 9px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    
    .remove-column-btn {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
    }

    .remove-column-btn:hover, .remove-row-btn:hover {
      background: #EF4444;
      color: white;
      border-color: #EF4444;
      transform: scale(1.05) translateY(-50%);
      box-shadow: 0 2px 6px rgba(239, 68, 68, 0.3);
    }

    .remove-column-btn:active, .remove-row-btn:active {
      transform: scale(0.95) translateY(-50%);
    }

    /* Series colour picker styles */
    .series-colour-picker {
      width: 20px;
      height: 20px;
      border: 2px solid #D1D5DB;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
      background: #F3F4F6;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      color: #6B7280;
      font-weight: 500;
      position: absolute;
      right: 30px;
      top: 50%;
      transform: translateY(-50%);
    }

    .series-colour-picker:hover {
      border-color: #3B82F6;
      transform: scale(1.05) translateY(-50%);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
    }

    .series-colour-picker.has-colour {
      background: var(--series-colour);
      color: white;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    .series-colour-picker.has-colour:hover {
      border-color: #1D4ED8;
    }

    .series-colour-input {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }

    /* Category colour picker styles */
    .category-colour-picker {
      width: 20px;
      height: 20px;
      border: 2px solid #D1D5DB;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
      background: #F3F4F6;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      color: #6B7280;
      font-weight: 500;
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
    }

    .category-colour-picker:hover {
      border-color: #3B82F6;
      transform: scale(1.05) translateY(-50%);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
    }

    .category-colour-picker.has-colour {
      background: var(--category-colour);
      color: white;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    .category-colour-picker.has-colour:hover {
      border-color: #1D4ED8;
    }

    .category-colour-input {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }

    .series-header-cell {
      white-space: nowrap;
      min-height: 32px;
      padding: 6px 8px;
      overflow: hidden;
      position: relative;
    }

    .series-name-input {
      width: calc(100% - 50px); /* Account for colour picker and remove button */
      border: none;
      background: transparent;
      padding: 2px 4px;
      font-size: 12px;
      font-family: inherit;
      display: inline-block;
    }

    .series-name-input:focus {
      outline: none;
      background: white;
      border: 1px solid #3B82F6;
      border-radius: 2px;
    }

  </style>
  <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
  <script>
    // Debug script to check if ApexCharts loads
    window.addEventListener('load', function() {
      console.log('Page loaded, checking ApexCharts...');
      if (typeof ApexCharts === 'undefined') {
        console.error('ApexCharts failed to load from CDN');
      } else {
        console.log('ApexCharts loaded successfully, version:', ApexCharts.version || 'unknown');
      }
    });
  </script>
</head>
<body>
  <div class="main-content">
    <div class="config-section" id="configSection">
      <div class="config-content">
        <div class="config-header">
          <div class="section-title">Chart Settings</div>
          <button class="toggle-button" id="togglePreview" title="Toggle preview">
            ←
          </button>
        </div>
        
        <div class="row">
          <label for="title">Chart title</label>
          <input id="title" placeholder="e.g., Monthly VFACTS Sales" />
        </div>

        <div class="row">
          <label for="type">Type</label>
          <select id="type">
            <option value="line">Line</option>
            <option value="bar">Bar</option>
            <option value="area">Area</option>
          </select>
        </div>

        <div class="row" id="horizontalToggleRow" style="display: none;">
          <label for="horizontal">Horizontal</label>
          <input id="horizontal" type="checkbox" />
        </div>

        <div class="row" id="stackedToggleRow" style="display: none;">
          <label for="stacked">Stacked</label>
          <input id="stacked" type="checkbox" />
        </div>

        <div class="row" id="markerSizeRow" style="display: none;">
          <label for="markerSize">Marker size</label>
          <input id="markerSize" type="number" placeholder="6" min="0" max="20" />
        </div>

        <div class="row">
          <label for="widthPreset">Width</label>
          <select id="widthPreset">
            <option value="article-desktop">Article Desktop (740px)</option>
            <option value="article-mobile">Article Mobile (350px)</option>
            <option value="full-width">Full width (1180px)</option>
            <option value="custom">Custom</option>
          </select>
        </div>
        
        <div class="row" id="customWidthRow" style="display: none;">
          <label for="width">Width (px)</label>
          <input id="width" type="number" placeholder="600" />
        </div>
        
        <div class="row">
          <label for="height">Height (px)</label>
          <input id="height" type="number" placeholder="400" />
        </div>

        <div class="row">
          <label for="showLegend">Show legend</label>
          <input id="showLegend" type="checkbox" checked />
        </div>

        <div class="row">
          <label for="showDataLabels">Show data labels</label>
          <input id="showDataLabels" type="checkbox" />
        </div>

        <div class="row">
          <label>Chart theme</label>
          <select id="chartTheme">
            <option value="neutral">Neutral (all grey)</option>
            <option value="brand">Brand (all red)</option>
            <option value="secondary">Secondary (all blue)</option>
            <option value="categorical">Categorical (multi-colour)</option>
            <option value="sequential-brand">Sequential Brand (red gradient)</option>
            <option value="sequential-secondary">Sequential Secondary (blue gradient)</option>
            <option value="diverging-1">Diverging 1 (red to green)</option>
            <option value="diverging-2">Diverging 2 (green to red)</option>
            <option value="diverging-3">Diverging 3 (red to blue)</option>
          </select>
        </div>

        <div class="row">
          <label>Highlight mode</label>
          <select id="colourMode">
            <option value="series">Series</option>
            <option value="category">Category</option>
          </select>
        </div>

        <div class="tab-container">
            <div class="tab-nav">
              <button class="tab-button active" data-tab="table">Table</button>
              <button class="tab-button" data-tab="json">JSON</button>
            </div>
            
            <div class="tab-content" id="json-tab">
              <textarea id="data" rows="8" placeholder='{"categories":["Sep 2024","Oct 2024"],"series":[{"name":"Ford Ranger (Current 12 months)","data":[5200,4950],"color":"#E11D48"},{"name":"Ford Ranger (Previous 12 months)","data":[4700,4600],"color":"#7D7D83"}]}'>{"categories":["Jan","Feb","Mar","Apr","May"],"series":[{"name":"Sales","data":[1200,1900,3000,5000,4000],"color":""},{"name":"Revenue","data":[1000,1500,2500,4200,3800],"color":""}]}</textarea>
            </div>
            
            <div class="tab-content active" id="table-tab">
              <div class="table-controls">
                <button class="add-series-btn" id="addColumn">+ Column</button>
                <button class="add-series-btn" id="addRow">+ Row</button>
              </div>
              <div class="table-container">
                <table class="data-table" id="dataTable">
                  <thead>
                    <tr id="headerRow">
                      <th>Categories</th>
                    </tr>
                  </thead>
                  <tbody id="tableBody">
                    <!-- Table rows will be generated dynamically -->
                  </tbody>
                </table>
              </div>
            </div>
        </div>
      </div>
      
      <div class="config-buttons">
        <div class="button-group">
          <button id="render">Render preview</button>
          <button id="insert">Insert into Figma</button>
        </div>
      </div>
    </div>
    
    <div class="preview-section" id="previewSection">
      <div id="preview"></div>
    </div>
  </div>

  <script>
    // ── Toggle functionality ─────────────────────────────────────────────────
    let previewVisible = true;
    
    function togglePreview() {
      const configSection = document.getElementById('configSection');
      const previewSection = document.getElementById('previewSection');
      const toggleButton = document.getElementById('togglePreview');
      
      previewVisible = !previewVisible;
      
      if (previewVisible) {
        // Show preview
        configSection.classList.remove('collapsed');
        previewSection.classList.remove('hidden');
        toggleButton.textContent = '←';
        toggleButton.title = 'Hide preview';
        
        // Resize window to accommodate preview
        parent.postMessage({ 
          pluginMessage: { 
            type: 'resize-window', 
            width: 1200, 
            height: 800 
          } 
        }, '*');
      } else {
        // Hide preview
        configSection.classList.add('collapsed');
        previewSection.classList.add('hidden');
        toggleButton.textContent = '→';
        toggleButton.title = 'Show preview';
        
        // Resize window to config section width only
        parent.postMessage({ 
          pluginMessage: { 
            type: 'resize-window', 
            width: 420, 
            height: 800 
          } 
        }, '*');
      }
    }
    
    document.getElementById('togglePreview').addEventListener('click', togglePreview);

    // ── Tab functionality ─────────────────────────────────────────────────
    let currentData = {
      categories: ["Jan", "Feb", "Mar", "Apr", "May"],
      series: [
        { name: "Sales", data: [1200, 1900, 3000, 5000, 4000], color: "" },
        { name: "Revenue", data: [1000, 1500, 2500, 4200, 3800], color: "" }
      ],
      categoryColours: ["", "", "", "", ""]
    };
    
    let jsonManuallyEdited = false;

    function switchTab(tabName) {
      // Update tab buttons
      document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
      });
      document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

      // Update tab content
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(`${tabName}-tab`).classList.add('active');

      // Sync data when switching between tabs
      if (tabName === 'table') {
        // If JSON was manually edited, sync from JSON to table
        if (jsonManuallyEdited) {
          syncJsonToTable();
          jsonManuallyEdited = false; // Reset flag after syncing
        } else {
          // Always ensure table is rendered with current data
          renderTable();
        }
      } else if (tabName === 'json') {
        // Always sync table data to JSON when switching to JSON tab
        syncTableToJson();
      }
    }

    // Tab button event listeners
    document.querySelectorAll('.tab-button').forEach(button => {
      button.addEventListener('click', () => {
        switchTab(button.dataset.tab);
      });
    });

    // ── Table management ─────────────────────────────────────────────────
    function syncJsonToTable() {
      try {
        const jsonData = JSON.parse(document.getElementById('data').value);
        if (jsonData && jsonData.categories && jsonData.series) {
          // Update currentData with JSON data
          currentData = jsonData;
          
          // Ensure categoryColours array exists
          if (!currentData.categoryColours) {
            currentData.categoryColours = new Array(currentData.categories.length).fill('');
          }
          
          // Re-render table with new data
          renderTable();
        }
      } catch (e) {
        // If JSON is invalid, keep current data and just re-render
        renderTable();
      }
      jsonManuallyEdited = false; // Reset flag after syncing from JSON
    }

    function syncTableToJson() {
      const categories = [];
      const series = [];
      const categoryColours = [];

      // Get categories from first column
      const categoryInputs = document.querySelectorAll('#tableBody tr td:first-child input');
      categoryInputs.forEach((input, index) => {
        const categoryValue = input.value.trim();
        // Filter out colour values and other invalid category names
        if (categoryValue && 
            categoryValue !== '#000000' && 
            !categoryValue.startsWith('#') && 
            categoryValue !== '') {
          categories.push(categoryValue);
          
          // Get category colour from colour picker
          const categoryColourPicker = input.parentElement.querySelector('.category-colour-picker');
          const categoryColour = categoryColourPicker ? categoryColourPicker.dataset.colour || '' : '';
          categoryColours.push(categoryColour);
        }
      });

      // Get series data
      const headerCells = document.querySelectorAll('#headerRow th:not(:first-child)');
      headerCells.forEach((header, seriesIndex) => {
        const seriesNameInput = header.querySelector('input');
        const seriesName = seriesNameInput ? seriesNameInput.value.trim() : '';
        
        if (seriesName) {
          const seriesData = [];
          const dataInputs = document.querySelectorAll(`#tableBody tr td:nth-child(${seriesIndex + 2}) input`);
          dataInputs.forEach(input => {
            const value = parseFloat(input.value) || 0;
            seriesData.push(value);
          });
          
          // Get colour from the series data (individual series colour overrides global palette)
          let seriesColor = "";
          
          // Check if this series has an individual colour set
          if (currentData.series[seriesIndex] && currentData.series[seriesIndex].color && currentData.series[seriesIndex].color.trim() !== '') {
            seriesColor = currentData.series[seriesIndex].color;
          }
          // If no individual colour, don't set color property (will use global palette)
          
          series.push({ name: seriesName, data: seriesData, color: seriesColor });
        }
      });

      // Update currentData with the latest table data
      currentData = { categories, series, categoryColours };
      
      // Debug logging
      console.log('syncTableToJson - categories:', categories);
      console.log('syncTableToJson - categoryColours:', categoryColours);
      console.log('syncTableToJson - series:', series);
      
      // Update JSON textarea
      document.getElementById('data').value = JSON.stringify(currentData, null, 2);
      
      // Reset flag since JSON was programmatically updated
      jsonManuallyEdited = false;
    }

    function renderTable() {
      const tableBody = document.getElementById('tableBody');
      const headerRow = document.getElementById('headerRow');
      
      // Clear existing content
      tableBody.innerHTML = '';
      
      // Update header row with X buttons
      headerRow.innerHTML = '<th><input type="text" placeholder="Category" value="" /></th>';
      
      currentData.series.forEach((series, index) => {
        const th = document.createElement('th');
        th.className = 'series-header-cell';
        
        // Series name input
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'series-name-input';
        input.placeholder = 'Series name';
        input.value = series.name || '';
        input.addEventListener('input', syncTableToJson);
        
        // Series colour picker
        const colourPicker = document.createElement('div');
        colourPicker.className = 'series-colour-picker';
        colourPicker.dataset.seriesIndex = index;
        colourPicker.title = 'Click to set override colour, double-click to clear override';
        
        // Only show colour if it's an override (individual series colour set)
        if (series.color && series.color.trim() !== '') {
          colourPicker.classList.add('has-colour');
          colourPicker.style.setProperty('--series-colour', series.color);
          colourPicker.textContent = '✓';
        } else {
          colourPicker.classList.remove('has-colour');
          colourPicker.textContent = '●';
        }
        
        // Hidden colour input
        const colourInput = document.createElement('input');
        colourInput.type = 'color';
        colourInput.className = 'series-colour-input';
        colourInput.value = series.color && series.color.trim() !== '' ? series.color : '#000000';
        colourInput.addEventListener('change', function() {
          const seriesIdx = parseInt(colourPicker.dataset.seriesIndex);
          console.log('Colour input changed for series:', seriesIdx, 'new value:', this.value);
          updateSeriesColour(seriesIdx, this.value);
        });
        
        colourPicker.addEventListener('click', function(e) {
          e.stopPropagation();
          colourInput.click();
        });
        
        // Double-click to clear override and return to global palette
        colourPicker.addEventListener('dblclick', function(e) {
          e.stopPropagation();
          updateSeriesColour(index, '');
        });
        
        colourPicker.appendChild(colourInput);
        
        // Add X button for removing column (but not for categories column)
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-column-btn';
        removeBtn.innerHTML = '×';
        removeBtn.title = 'Remove column';
        removeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          removeColumn(index);
        });
        
        th.appendChild(input);
        th.appendChild(colourPicker);
        th.appendChild(removeBtn);
        
        headerRow.appendChild(th);
      });
      
      // Add empty header cell for remove row buttons at the end
      const removeRowHeader = document.createElement('th');
      removeRowHeader.style.width = '40px';
      removeRowHeader.style.minWidth = '40px';
      removeRowHeader.style.textAlign = 'center';
      headerRow.appendChild(removeRowHeader);

      // Create data rows
      const maxLength = Math.max(
        currentData.categories.length,
        ...currentData.series.map(s => s.data.length)
      );

      for (let i = 0; i < maxLength; i++) {
        const row = document.createElement('tr');
        
        // Category cell
        const categoryCell = document.createElement('td');
        categoryCell.style.position = 'relative';
        
        const categoryInput = document.createElement('input');
        categoryInput.type = 'text';
        categoryInput.placeholder = 'Category';
        categoryInput.value = currentData.categories[i] || '';
        categoryInput.style.width = 'calc(100% - 30px)';
        categoryInput.addEventListener('input', syncTableToJson);
        categoryCell.appendChild(categoryInput);
        
        // Category colour picker
        const categoryColourPicker = document.createElement('div');
        categoryColourPicker.className = 'category-colour-picker';
        categoryColourPicker.dataset.categoryIndex = i;
        categoryColourPicker.title = 'Click to set category colour, double-click to clear';
        
        // Set initial colour
        const categoryColour = currentData.categoryColours && currentData.categoryColours[i] ? currentData.categoryColours[i] : '';
        if (categoryColour && categoryColour.trim() !== '') {
          categoryColourPicker.classList.add('has-colour');
          categoryColourPicker.style.setProperty('--category-colour', categoryColour);
          categoryColourPicker.textContent = '✓';
          categoryColourPicker.dataset.colour = categoryColour;
        } else {
          categoryColourPicker.classList.remove('has-colour');
          categoryColourPicker.textContent = '●';
          categoryColourPicker.dataset.colour = '';
        }
        
        // Hidden colour input
        const categoryColourInput = document.createElement('input');
        categoryColourInput.type = 'color';
        categoryColourInput.className = 'category-colour-input';
        categoryColourInput.value = categoryColour || '#000000';
        categoryColourInput.addEventListener('change', function() {
          const categoryIdx = parseInt(categoryColourPicker.dataset.categoryIndex);
          updateCategoryColour(categoryIdx, this.value);
        });
        
        // Prevent colour input from affecting category input
        categoryColourInput.addEventListener('input', function(e) {
          e.stopPropagation();
        });
        
        categoryColourPicker.addEventListener('click', function(e) {
          e.stopPropagation();
          categoryColourInput.click();
        });
        
        // Double-click to clear override
        categoryColourPicker.addEventListener('dblclick', function(e) {
          e.stopPropagation();
          updateCategoryColour(i, '');
        });
        
        categoryColourPicker.appendChild(categoryColourInput);
        categoryCell.appendChild(categoryColourPicker);
        row.appendChild(categoryCell);

        // Series data cells
        currentData.series.forEach((series, seriesIndex) => {
          const dataCell = document.createElement('td');
          const dataInput = document.createElement('input');
          dataInput.type = 'number';
          dataInput.placeholder = '0';
          dataInput.value = series.data[i] || '';
          dataInput.addEventListener('input', syncTableToJson);
          dataCell.appendChild(dataInput);
          row.appendChild(dataCell);
        });

        // Add X button for removing row in a separate cell
        const removeRowCell = document.createElement('td');
        removeRowCell.style.textAlign = 'center';
        removeRowCell.style.width = '40px';
        removeRowCell.style.minWidth = '40px';
        const removeRowBtn = document.createElement('button');
        removeRowBtn.className = 'remove-row-btn';
        removeRowBtn.innerHTML = '×';
        removeRowBtn.title = 'Remove row';
        removeRowBtn.addEventListener('click', () => removeRow(i));
        removeRowCell.appendChild(removeRowBtn);
        row.appendChild(removeRowCell);

        tableBody.appendChild(row);
      }
    }

    function addColumn() {
      currentData.series.push({ name: `Series ${currentData.series.length + 1}`, data: new Array(currentData.categories.length).fill(0), color: "" });
      renderTable();
      syncTableToJson();
    }

    function updateSeriesColour(seriesIndex, colour) {
      console.log('updateSeriesColour called:', seriesIndex, colour);
      if (currentData.series[seriesIndex]) {
        // Set the individual series colour (this overrides the global palette)
        // If colour is empty or default, clear the override
        if (colour && colour.trim() !== '' && colour !== '#000000') {
          currentData.series[seriesIndex].color = colour;
          console.log('Set series', seriesIndex, 'colour to:', colour);
        } else {
          currentData.series[seriesIndex].color = '';
          console.log('Cleared series', seriesIndex, 'colour override');
        }
        
        // Update the colour picker display without re-rendering the entire table
        const colourPicker = document.querySelector(`[data-series-index="${seriesIndex}"]`);
        if (colourPicker) {
          // Get the existing colour input before updating content
          const existingColourInput = colourPicker.querySelector('.series-colour-input');
          
          // Only show as having colour if it's a real override
          if (currentData.series[seriesIndex].color && currentData.series[seriesIndex].color.trim() !== '') {
            colourPicker.classList.add('has-colour');
            colourPicker.style.setProperty('--series-colour', currentData.series[seriesIndex].color);
            colourPicker.textContent = '✓';
          } else {
            colourPicker.classList.remove('has-colour');
            colourPicker.textContent = '●';
          }
          
          // Re-append the colour input if it existed
          if (existingColourInput) {
            existingColourInput.value = currentData.series[seriesIndex].color || '#000000';
            colourPicker.appendChild(existingColourInput);
          }
        }
        
        // Always sync to JSON to ensure persistence when switching tabs
        syncTableToJson();
        
        // Update theme selection based on current state
        const currentTheme = detectCurrentTheme();
        if (currentTheme) {
          document.getElementById('chartTheme').value = currentTheme;
        }
      }
    }

    function updateCategoryColour(categoryIndex, colour) {
      console.log('updateCategoryColour called:', categoryIndex, colour);
      
      // Ensure categoryColours array exists
      if (!currentData.categoryColours) {
        currentData.categoryColours = new Array(currentData.categories.length).fill('');
      }
      
      // Set the individual category colour
      if (colour && colour.trim() !== '' && colour !== '#000000') {
        currentData.categoryColours[categoryIndex] = colour;
        console.log('Set category', categoryIndex, 'colour to:', colour);
      } else {
        currentData.categoryColours[categoryIndex] = '';
        console.log('Cleared category', categoryIndex, 'colour override');
      }
      
      // Update the colour picker display without re-rendering the entire table
      const colourPicker = document.querySelector(`[data-category-index="${categoryIndex}"]`);
      if (colourPicker) {
        // Get the existing colour input before updating content
        const existingColourInput = colourPicker.querySelector('.category-colour-input');
        
        // Only show as having colour if it's a real override
        if (currentData.categoryColours[categoryIndex] && currentData.categoryColours[categoryIndex].trim() !== '') {
          colourPicker.classList.add('has-colour');
          colourPicker.style.setProperty('--category-colour', currentData.categoryColours[categoryIndex]);
          colourPicker.textContent = '✓';
          colourPicker.dataset.colour = currentData.categoryColours[categoryIndex];
        } else {
          colourPicker.classList.remove('has-colour');
          colourPicker.textContent = '●';
          colourPicker.dataset.colour = '';
        }
        
        // Re-append the colour input if it existed
        if (existingColourInput) {
          existingColourInput.value = currentData.categoryColours[categoryIndex] || '#000000';
          colourPicker.appendChild(existingColourInput);
        }
      }
      
      // Always sync to JSON to ensure persistence when switching tabs
      syncTableToJson();
      
      // Update theme selection based on current state
      const currentTheme = detectCurrentTheme();
      if (currentTheme) {
        document.getElementById('chartTheme').value = currentTheme;
      }
    }

    function removeColumn(columnIndex) {
      if (currentData.series.length > 1) {
        currentData.series.splice(columnIndex, 1);
        renderTable();
        syncTableToJson();
      }
    }

    function addRow() {
      currentData.categories.push(`Category ${currentData.categories.length + 1}`);
      currentData.series.forEach(series => {
        series.data.push(0);
      });
      
      // Ensure categoryColours array exists and add empty colour for new category
      if (!currentData.categoryColours) {
        currentData.categoryColours = new Array(currentData.categories.length - 1).fill('');
      }
      currentData.categoryColours.push('');
      
      renderTable();
      syncTableToJson();
    }

    function removeRow(rowIndex) {
      if (currentData.categories.length > 1) {
        currentData.categories.splice(rowIndex, 1);
        currentData.series.forEach(series => {
          series.data.splice(rowIndex, 1);
        });
        
        // Remove category colour as well
        if (currentData.categoryColours) {
          currentData.categoryColours.splice(rowIndex, 1);
        }
        
        renderTable();
        syncTableToJson();
      }
    }

    function applyTheme(themeName) {
      // Update the global BRAND palette
      if (THEMES[themeName]) {
        BRAND.palette = THEMES[themeName];
        
        // Clear all individual series and category colour overrides
        currentData.series.forEach(series => {
          series.color = '';
        });
        
        if (currentData.categoryColours) {
          currentData.categoryColours.fill('');
        }
        
        console.log('Applied theme:', themeName, 'with palette:', BRAND.palette);
        
        // Re-render table to show updated colours
        renderTable();
        syncTableToJson();
      }
    }

    function detectCurrentTheme() {
      // Check if current palette matches any theme
      const currentPalette = BRAND.palette;
      
      // Only detect theme if no individual colours are set
      const hasIndividualSeriesColours = currentData.series.some(series => series.color && series.color.trim() !== '');
      const hasIndividualCategoryColours = currentData.categoryColours && currentData.categoryColours.some(colour => colour && colour.trim() !== '');
      
      if (hasIndividualSeriesColours || hasIndividualCategoryColours) {
        return null; // Individual colours override theme detection
      }
      
      // Check each theme
      for (const [themeName, themePalette] of Object.entries(THEMES)) {
        if (JSON.stringify(currentPalette) === JSON.stringify(themePalette)) {
          return themeName;
        }
      }
      
      return null; // No theme matches
    }

    // Table control event listeners
    document.getElementById('addColumn').addEventListener('click', addColumn);
    document.getElementById('addRow').addEventListener('click', addRow);

    // Colour mode change handler
    function handleColourModeChange() {
      const colourMode = document.getElementById('colourMode').value;
      
      // Ensure categoryColours array exists for category mode
      if (colourMode === 'category') {
        if (!currentData.categoryColours) {
          currentData.categoryColours = new Array(currentData.categories.length).fill('');
        }
      }
      
      // Update theme selection based on current state
      const currentTheme = detectCurrentTheme();
      if (currentTheme) {
        document.getElementById('chartTheme').value = currentTheme;
      }
    }

    // Colour mode event listener
    document.getElementById('colourMode').addEventListener('change', handleColourModeChange);

    // Theme change event listener
    document.getElementById('chartTheme').addEventListener('change', function() {
      const selectedTheme = this.value;
      applyTheme(selectedTheme);
    });

    // Sync JSON to table when JSON textarea changes
    document.getElementById('data').addEventListener('input', () => {
      jsonManuallyEdited = true; // Mark that JSON has been manually edited
      if (document.getElementById('table-tab').classList.contains('active')) {
        syncJsonToTable();
        jsonManuallyEdited = false; // Reset since we just synced
      }
    });


    // ── Brand tokens (edit once, used everywhere) ────────────────────────────
    var BRAND = {
      fontFamily: "'Anek Latin', Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif",
      foreColor: "#0F172A",     // text
      axisColor: "#334155",     // axis/labels
      subtitleColor: "#475569",
      gridColor: "#E2E8F0",
      palette: ["#AFAFB3"], // Default to neutral theme
      sizes: { label: "12px", legend: "12px", title: "16px", subtitle: "12px", dataLabel: "12px" },
      weights: { label: 400, legend: 500, title: 600, subtitle: 500, dataLabel: 600 }
    };

    // ── Chart theme definitions ───────────────────────────────────────────────
    var THEMES = {
      neutral: ["#AFAFB3"],
      brand: ["#EB0800"],
      secondary: ["#0A6EFA"],
      categorical: ["#E11D48", "#7D7D83", "#22C55E", "#F59E0B", "#8B5CF6", "#10B981", "#F43F5E"],
      "sequential-brand": ["#FF6B6B", "#FF5252", "#EB0800", "#D32F2F", "#C62828"],
      "sequential-secondary": ["#64B5F6", "#42A5F5", "#0A6EFA", "#1976D2", "#1565C0"],
      "diverging-1": ["#EB0800", "#FF9800", "#FFEB3B", "#8BC34A", "#4CAF50"],
      "diverging-2": ["#4CAF50", "#8BC34A", "#FFEB3B", "#FF9800", "#EB0800"],
      "diverging-3": ["#EB0800", "#E91E63", "#9C27B0", "#673AB7", "#0A6EFA"]
    };
    
    // Set initial theme based on current palette (after BRAND is defined)
    const currentTheme = detectCurrentTheme();
    if (currentTheme) {
      document.getElementById('chartTheme').value = currentTheme;
    }

    // Initialize table on page load
    renderTable();

    // Initialize chart type handler to set initial state
    handleChartTypeChange();
    
    // Initialize colour mode handler to set initial state
    handleColourModeChange();

    var chart = null;

    function parseData(raw) {
      try { return JSON.parse(raw); } catch(e) { return null; }
    }

    // ── Width preset handling ───────────────────────────────────────────────
    function getWidthValue() {
      var preset = document.getElementById('widthPreset').value;
      var customWidth = parseInt(document.getElementById('width').value, 10);
      
      switch (preset) {
        case 'article-desktop':
          return 740;
        case 'article-mobile':
          return 350;
        case 'full-width':
          return 1180;
        case 'custom':
          return customWidth || 600;
        default:
          return 600;
      }
    }
    
    function handleWidthPresetChange() {
      var preset = document.getElementById('widthPreset').value;
      var customRow = document.getElementById('customWidthRow');
      
      if (preset === 'custom') {
        customRow.style.display = 'flex';
      } else {
        customRow.style.display = 'none';
      }
    }

    // ── Branded defaults (keeps width/height support) ───────────────────────
    function baseOptions() {
      var type = document.getElementById('type').value;
      var width = getWidthValue();
      var height = parseInt(document.getElementById('height').value, 10) || 400;
      var isHorizontal = type === "bar" && document.getElementById('horizontal').checked;
      var isStacked = type === "bar" && document.getElementById('stacked').checked;
      var showDataLabels = document.getElementById('showDataLabels').checked;

      return {
        chart: {
          type: type === "bar" ? "bar" : type,
          width: width,
          height: height,
          fontFamily: BRAND.fontFamily,
          foreColor: BRAND.foreColor,
          animations: { enabled: false },
          toolbar: { show: false },
          stacked: isStacked
        },
        
        // Store horizontal state and categories for tooltip access
        isHorizontal: isHorizontal,
        chartCategories: [], // Will be set in render function
        colors: BRAND.palette,

        title: {
          text: document.getElementById('title').value || "",
          style: {
            fontSize: BRAND.sizes.title,
            fontWeight: BRAND.weights.title,
            fontFamily: BRAND.fontFamily,
            color: BRAND.foreColor
          }
        },
        subtitle: {
          text: "",
          style: {
            fontSize: BRAND.sizes.subtitle,
            fontWeight: BRAND.weights.subtitle,
            fontFamily: BRAND.fontFamily,
            color: BRAND.subtitleColor
          }
        },

        xaxis: {
          categories: [],
          axisBorder: { show: true, color: BRAND.gridColor },
          axisTicks:  { show: true, color: BRAND.gridColor },
          crosshairs: {
            show: false
          },
          labels: {
            formatter: function(v){ return (isHorizontal) ? Number(v).toLocaleString() : v; },
            style: {
              colors: BRAND.axisColor,
              fontSize: BRAND.sizes.label,
              fontFamily: BRAND.fontFamily,
              fontWeight: BRAND.weights.label
            }
          }
        },
        yaxis: {
          crosshairs: {
            show: false
          },
          labels: {
            formatter: function(v, opts) { 
              if (isHorizontal) {
                // For horizontal charts, v should be the category name
                // If it's a number, try to get the category from the chart categories
                if (typeof v === 'number' && opts && opts.w && opts.w.config && opts.w.config.chartCategories) {
                  return opts.w.config.chartCategories[v - 1] || v;
                }
                return v;
              } else {
                return Number(v).toLocaleString();
              }
            },
            style: {
              colors: BRAND.axisColor,
              fontSize: BRAND.sizes.label,
              fontFamily: BRAND.fontFamily,
              fontWeight: BRAND.weights.label
            }
          }
        },

        grid: { 
          borderColor: BRAND.gridColor, 
          strokeDashArray: 3, 
          padding: { left: 8, right: 8 },
          xaxis: {
            lines: {
              show: false
            }
          }
        },
        stroke: { width: (type === "bar" ? 0 : 2), lineCap: "round", curve: "smooth" },
        markers: { size: ((type === "line" || type === "area") ? (parseInt(document.getElementById('markerSize').value, 10) || 5) : 0), strokeWidth: 2, strokeColors: "#fff" },

        plotOptions: {
          bar: { 
            columnWidth: "55%", 
            borderRadius: 0,
            horizontal: isHorizontal
          },
          area: { fillTo: "origin" }
        },
        fill: {
          type: "solid",
          opacity: (type === "area" ? 0.18 : 1)
        },

        dataLabels: {
          enabled: showDataLabels,
          style: {
            fontSize: BRAND.sizes.dataLabel,
            fontFamily: BRAND.fontFamily,
            fontWeight: BRAND.weights.dataLabel,
            colors: [BRAND.foreColor]
          }
        },

        legend: {
          show: true,
          position: "bottom",
          horizontalAlign: "center",
          fontSize: BRAND.sizes.legend,
          fontFamily: BRAND.fontFamily,
          fontWeight: BRAND.weights.legend,
          markers: { 
            radius: 3,
            strokeWidth: 0,
            strokeColor: '#fff'
          },
          itemMargin: {
            horizontal: 10,
            vertical: 5
          },
          offsetY: 5
        },

        tooltip: {
          theme: "light",
          style: { fontSize: BRAND.sizes.label, fontFamily: BRAND.fontFamily },
          enabled: true,
          shared: true,
          intersect: false,
          followCursor: false,
          custom: function({series, seriesIndex, dataPointIndex, w}) {
            // Use the stored horizontal state and categories from chart config
            var isHorizontalChart = w.config.isHorizontal || false;
            var categories = w.config.chartCategories || [];
            
            // For horizontal charts, the data is in x,y format
            var categoryValue, value;
            if (isHorizontalChart && series[seriesIndex] && series[seriesIndex][dataPointIndex] && typeof series[seriesIndex][dataPointIndex] === 'object') {
              // Data is in {x: category, y: value} format
              categoryValue = series[seriesIndex][dataPointIndex].x;
              value = series[seriesIndex][dataPointIndex].y;
            } else {
              // Traditional format or fallback
              categoryValue = categories && categories[dataPointIndex] ? categories[dataPointIndex] : (dataPointIndex + 1);
              value = series[seriesIndex][dataPointIndex];
            }
            
            // Debug logging
            console.log('Tooltip debug:', {
              isHorizontalChart: isHorizontalChart,
              dataPointIndex: dataPointIndex,
              chartCategories: categories,
              categoryValue: categoryValue,
              value: value
            });
            
            var tooltipContent = '<div style="padding: 8px;">';
            tooltipContent += '<div style="font-weight: 600; margin-bottom: 4px;">' + categoryValue + '</div>';
            
            series.forEach(function(seriesData, index) {
              if (seriesData[dataPointIndex] !== null && seriesData[dataPointIndex] !== undefined) {
                var seriesName = w.config.series[index].name || 'Series ' + (index + 1);
                var seriesValue;
                var seriesColor = w.config.colors[index % w.config.colors.length];
                
                // Handle different data formats
                if (isHorizontalChart && typeof seriesData[dataPointIndex] === 'object') {
                  // Data is in {x: category, y: value} format
                  seriesValue = Number(seriesData[dataPointIndex].y).toLocaleString();
                } else {
                  // Traditional format
                  seriesValue = Number(seriesData[dataPointIndex]).toLocaleString();
                }
                
                // For category mode, try to get the actual colour from the data point
                if (w.config.series[index].data && w.config.series[index].data[dataPointIndex] && w.config.series[index].data[dataPointIndex].fillColor) {
                  seriesColor = w.config.series[index].data[dataPointIndex].fillColor;
                } else if (w.config.series[index].color) {
                  seriesColor = w.config.series[index].color;
                }
                
                tooltipContent += '<div style="display: flex; align-items: center; margin: 2px 0;">';
                tooltipContent += '<div style="width: 8px; height: 8px; background-color: ' + seriesColor + '; border-radius: 50%; margin-right: 6px;"></div>';
                tooltipContent += '<span style="font-size: 12px;">' + seriesName + ': ' + seriesValue + '</span>';
                tooltipContent += '</div>';
              }
            });
            
            tooltipContent += '</div>';
            return tooltipContent;
          },
          crosshairs: {
            show: false
          }
        },

        series: []
      };
    }

    async function render() {
      // Check if ApexCharts is available
      if (typeof ApexCharts === 'undefined') {
        console.error('ApexCharts is not loaded!');
        parent.postMessage({ pluginMessage: { type: 'notify', message: 'ApexCharts library failed to load' } }, '*');
        return;
      }
      
      console.log('ApexCharts is available, starting render...');
      
      // Get chart type for category assignment
      var type = document.getElementById('type').value;
      
      // If we're on JSON tab and JSON was manually edited, parse from JSON textarea
      // Otherwise use currentData
      var json;
      if (document.getElementById('json-tab').classList.contains('active') && jsonManuallyEdited) {
        try {
          json = JSON.parse(document.getElementById('data').value);
        } catch (e) {
          console.error('JSON parse error:', e);
          parent.postMessage({ pluginMessage: { type: 'notify', message: 'Invalid JSON format' } }, '*');
          return;
        }
      } else {
        json = currentData;
      }
      
      if (!json || !Array.isArray(json.series)) {
        console.error('Invalid data structure:', json);
        parent.postMessage({ pluginMessage: { type: 'notify', message: 'Invalid data: expected { categories, series }' } }, '*');
        return;
      }

      var options = baseOptions();
      
      // Get colour mode
      var colourMode = document.getElementById('colourMode').value;
      
      // Process series based on colour mode
      var processedSeries = json.series.map(function(series, index) {
        var processedSeries = {
          name: series.name,
          data: series.data
        };
        
        if (colourMode === 'category') {
          // Category mode: don't set individual series colours
          // We'll handle category colours at the chart level
        } else {
          // Series mode: traditional series-based colouring
          // Check if any series has individual colours set
          var hasIndividualColours = json.series.some(series => series.color && series.color.trim() !== '');
          
          // If series has a custom colour, add it to the series object
          if (series.color && series.color.trim() !== '') {
            processedSeries.color = series.color;
            console.log('Setting individual colour for series', index, ':', series.color);
          } else {
            // For series without individual colours, explicitly set the palette colour
            // to prevent ApexCharts from using its default palette
            var paletteIndex = index % options.colors.length;
            processedSeries.color = options.colors[paletteIndex];
            console.log('Setting palette colour for series', index, ':', options.colors[paletteIndex], 'from palette index', paletteIndex);
          }
        }
        
        return processedSeries;
      });
      
      options.series = processedSeries;
      
      // Handle category colours if in category mode
      if (colourMode === 'category' && json.categoryColours && json.categoryColours.length > 0) {
        // For category mode, we'll modify each series to have data points with individual colours
        options.series = options.series.map(function(series, seriesIndex) {
          var newSeries = {
            name: series.name,
            data: series.data.map(function(value, dataIndex) {
              var categoryColour = json.categoryColours[dataIndex];
              if (categoryColour && categoryColour.trim() !== '') {
                return {
                  x: json.categories[dataIndex],
                  y: value,
                  fillColor: categoryColour
                };
              } else {
                // Use palette colour if no category colour is set
                var paletteIndex = dataIndex % options.colors.length;
                return {
                  x: json.categories[dataIndex],
                  y: value,
                  fillColor: options.colors[paletteIndex]
                };
              }
            })
          };
          return newSeries;
        });
        
        console.log('Category mode - modified series with individual colours');
      }
      
      // For horizontal bar charts, categories go on y-axis, data values on x-axis
      var isHorizontal = type === "bar" && document.getElementById('horizontal').checked;
      
      console.log('Category assignment debug:', {
        type: type,
        isHorizontal: isHorizontal,
        categories: json.categories,
        categoriesLength: json.categories ? json.categories.length : 0,
        categoryColours: json.categoryColours,
        series: json.series
      });
      
      if (isHorizontal) {
        // For horizontal bar charts, we need to transform the data format
        // and configure the yaxis properly
        options.yaxis.categories = json.categories || [];
        options.xaxis.categories = [];
        options.chartCategories = json.categories || [];
        
        // Transform series data to use x,y format for horizontal charts
        // But only if not already transformed by category mode
        options.series = options.series.map(function(series) {
          var transformedData = series.data.map(function(value, index) {
            // If data is already in object format (from category mode), use it as-is
            if (typeof value === 'object' && value !== null) {
              return value;
            }
            // Otherwise, transform from simple array format
            return {
              x: json.categories[index] || (index + 1),
              y: value
            };
          });
          return {
            name: series.name,
            data: transformedData,
            color: series.color
          };
        });
        
        console.log('Assigned categories to yaxis:', options.yaxis.categories);
        console.log('Transformed series data for horizontal chart:', options.series);
        console.log('Category mode and horizontal chart - data format check:', {
          colourMode: colourMode,
          isHorizontal: isHorizontal,
          firstSeriesData: options.series[0] ? options.series[0].data.slice(0, 3) : 'no series'
        });
      } else {
        options.xaxis.categories = json.categories || [];
        options.yaxis.categories = [];
        options.chartCategories = json.categories || [];
        console.log('Assigned categories to xaxis:', options.xaxis.categories);
      }
      
      // Show legend based on user preference and data
      var legendCheckbox = document.getElementById('showLegend').checked;
      var hasMultipleSeriesOrNames = json.series.length > 1 || (json.series.length === 1 && json.series[0].name);
      var showLegend = legendCheckbox && hasMultipleSeriesOrNames;
      options.legend.show = showLegend;

      var el = document.getElementById('preview');
      el.innerHTML = '';
      
      console.log('Creating ApexCharts with options:', options);
      console.log('Final options xaxis categories:', options.xaxis.categories);
      console.log('Final options yaxis categories:', options.yaxis.categories);
      
      try {
        chart = new ApexCharts(el, options);
        console.log('ApexCharts instance created successfully');
        await chart.render();
        console.log('Chart rendered successfully');
      } catch (error) {
        console.error('Error creating or rendering chart:', error);
        parent.postMessage({ pluginMessage: { type: 'notify', message: 'Chart rendering failed: ' + error.message } }, '*');
        return;
      }
      
      // Debug: Check if legend was rendered
      setTimeout(function() {
        var svg = document.querySelector('#preview svg');
        var previewDiv = document.querySelector('#preview');
        
        if (svg) {
          var legendElements = svg.querySelectorAll('.apexcharts-legend, .apexcharts-legend-series, .apexcharts-legend-text');
          console.log('After render - Legend elements in SVG:', legendElements.length);
          
          // Check if legend exists outside SVG in the preview div
          var legendOutsideSvg = previewDiv.querySelectorAll('.apexcharts-legend, .apexcharts-legend-series, .apexcharts-legend-text');
          console.log('Legend elements outside SVG:', legendOutsideSvg.length);
          
          console.log('Legend show setting:', showLegend);
          console.log('Series count:', json.series.length);
          if (json.series.length > 0) {
            console.log('Series names:', json.series.map(s => s.name));
          }
          
          // Log all elements in preview to see what's there
          console.log('All elements in preview:', previewDiv.children.length);
          for (var i = 0; i < previewDiv.children.length; i++) {
            console.log('Child', i, ':', previewDiv.children[i].tagName, previewDiv.children[i].className);
          }
        }
      }, 100);

    }


    function createManualLegend(svgClone, seriesData) {
      if (!seriesData || seriesData.length === 0) return;
      
      // Only create legend if we have multiple series or single series with a name
      var shouldCreateLegend = seriesData.length > 1 || (seriesData.length === 1 && seriesData[0].name);
      if (!shouldCreateLegend) return;
      
      // Get SVG dimensions
      var svgWidth = parseFloat(svgClone.getAttribute('width')) || 600;
      var svgHeight = parseFloat(svgClone.getAttribute('height')) || 400;
      
      // Calculate legend dimensions
      var itemWidth = 120; // Approximate width per legend item
      var itemHeight = 20;
      var itemSpacing = 10;
      
      // Filter series with names
      var namedSeries = seriesData.filter(function(series) { return series.name; });
      var legendWidth = namedSeries.length * itemWidth;
      var legendHeight = itemHeight;
      
      // Position legend at bottom center with proper spacing from x-axis
      var legendX = (svgWidth - legendWidth) / 2;
      var legendY = svgHeight - 25; // Moved down a tad - closer to bottom edge
      
      // Create legend group
      var legendGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      legendGroup.setAttribute('class', 'manual-legend');
      legendGroup.setAttribute('transform', 'translate(' + legendX + ', ' + legendY + ')');
      
      var currentX = 0;
      
      namedSeries.forEach(function(series, index) {
        // Create legend item group
        var itemGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        itemGroup.setAttribute('transform', 'translate(' + currentX + ', 0)');
        
        // Create legend marker (circle)
        var marker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        marker.setAttribute('cx', '6');
        marker.setAttribute('cy', '10');
        marker.setAttribute('r', '3');
        
        // Use series-specific colour if available, otherwise fall back to palette
        var seriesColour = series.color;
        if (!seriesColour || seriesColour.trim() === '') {
          var currentPalette = BRAND.palette;
          seriesColour = currentPalette[index % currentPalette.length];
        }
        marker.setAttribute('fill', seriesColour);
        
        // Create legend text
        var text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', '16');
        text.setAttribute('y', '14');
        text.setAttribute('font-family', BRAND.fontFamily);
        text.setAttribute('font-size', BRAND.sizes.legend);
        text.setAttribute('font-weight', BRAND.weights.legend);
        text.setAttribute('fill', BRAND.foreColor);
        text.textContent = series.name;
        
        itemGroup.appendChild(marker);
        itemGroup.appendChild(text);
        legendGroup.appendChild(itemGroup);
        
        currentX += itemWidth;
      });
      
      // Insert legend at the end of SVG (so it appears on top)
      svgClone.appendChild(legendGroup);
    }

    function getSvgString() {
      var svg = document.querySelector('#preview svg');
      if (!svg) return null;
      
      // Clone the SVG to avoid modifying the original
      var svgClone = svg.cloneNode(true);
      
      // Check if legend exists in SVG
      var legendElements = svgClone.querySelectorAll('.apexcharts-legend, .apexcharts-legend-series, .apexcharts-legend-text');
      var hasLegend = legendElements.length > 0;
      
      // If no legend found in SVG, but user wants legend and we have multiple series, create manual legend
      var userWantsLegend = document.getElementById('showLegend').checked;
      if (!hasLegend && userWantsLegend && chart && chart.w && chart.w.config && chart.w.config.series) {
        var seriesData = chart.w.config.series;
        if (seriesData.length > 1 || (seriesData.length === 1 && seriesData[0].name)) {
          console.log('Creating manual legend for', seriesData.length, 'series');
          createManualLegend(svgClone, seriesData);
          hasLegend = true;
        }
      }
      
      // Ensure all text elements have explicit font-family attributes
      var textElements = svgClone.querySelectorAll('text, tspan');
      textElements.forEach(function(textElement) {
        // Set explicit font-family attribute
        textElement.setAttribute('font-family', "'Anek Latin', Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif");
        
        // Also set font-weight if not already set
        if (!textElement.getAttribute('font-weight')) {
          var computedStyle = window.getComputedStyle(textElement);
          textElement.setAttribute('font-weight', computedStyle.fontWeight || '400');
        }
        
        // Set font-size if not already set
        if (!textElement.getAttribute('font-size')) {
          var computedStyle = window.getComputedStyle(textElement);
          textElement.setAttribute('font-size', computedStyle.fontSize || '12px');
        }
      });
      
      console.log('Final SVG has legend:', hasLegend);
      return svgClone.outerHTML;
    }

    // Chart type change handler
    function handleChartTypeChange() {
      var chartType = document.getElementById('type').value;
      var horizontalRow = document.getElementById('horizontalToggleRow');
      var stackedRow = document.getElementById('stackedToggleRow');
      var markerSizeRow = document.getElementById('markerSizeRow');
      
      if (chartType === 'bar') {
        horizontalRow.style.display = 'flex';
        stackedRow.style.display = 'flex';
        markerSizeRow.style.display = 'none';
      } else if (chartType === 'line') {
        horizontalRow.style.display = 'none';
        stackedRow.style.display = 'none';
        markerSizeRow.style.display = 'flex';
      } else {
        horizontalRow.style.display = 'none';
        stackedRow.style.display = 'none';
        markerSizeRow.style.display = 'none';
      }
    }

    // Width preset event listener
    document.getElementById('widthPreset').addEventListener('change', handleWidthPresetChange);

    // Chart type event listener
    document.getElementById('type').addEventListener('change', handleChartTypeChange);

    document.getElementById('render').addEventListener('click', render);

    document.getElementById('insert').addEventListener('click', async function () {
      if (!chart) { await render(); }
      var svg = getSvgString();
      var title = document.getElementById('title').value || 'Apex Chart';
      
      var width = getWidthValue();
      var height = parseInt(document.getElementById('height').value, 10) || 400;
      
      var meta = { 
        title: title,
        width: width,
        height: height
      };
      
      if (svg) {
        parent.postMessage({ 
          pluginMessage: { 
            type: 'insert-svg', 
            svg: svg, 
            meta: meta
          } 
        }, '*');
      }
    });
  </script>
</body>
</html>
